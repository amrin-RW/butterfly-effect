import {
  isWebGL2Available,
  react_merge_refs_esm_default
} from "./chunk-Z5KST32V.js";
import {
  _extends,
  init_extends,
  init_react_three_fiber_esm,
  useFrame,
  useLoader,
  useThree
} from "./chunk-HENFT3N6.js";
import {
  require_react
} from "./chunk-CW3Q3AZN.js";
import {
  BlendFunction,
  BloomEffect,
  BrightnessContrastEffect,
  ChromaticAberrationEffect,
  ColorAverageEffect,
  ColorDepthEffect,
  DepthDownsamplingPass,
  DepthEffect,
  DepthOfFieldEffect,
  DotScreenEffect,
  EdgeDetectionMode,
  EffectComposer,
  EffectPass,
  GlitchEffect,
  GlitchMode,
  GodRaysEffect,
  GridEffect,
  HueSaturationEffect,
  LUT3DEffect,
  NoiseEffect,
  NormalPass,
  OutlineEffect,
  PixelationEffect,
  RenderPass,
  SMAAEffect,
  SMAAImageLoader,
  SMAAPreset,
  SSAOEffect,
  ScanlineEffect,
  SelectiveBloomEffect,
  SepiaEffect,
  ShockWaveEffect,
  TextureEffect,
  ToneMappingEffect,
  VignetteEffect
} from "./chunk-Q3KCNVWT.js";
import {
  HalfFloatType,
  RepeatWrapping,
  TextureLoader,
  Vector2,
  Vector3,
  init_three_module,
  sRGBEncoding
} from "./chunk-PJLJJBSA.js";
import {
  __objRest,
  __spreadProps,
  __spreadValues,
  __toESM
} from "./chunk-IGMYUX52.js";

// node_modules/@react-three/postprocessing/dist/index.js
var import_react = __toESM(require_react(), 1);
init_three_module();
init_three_module();
init_react_three_fiber_esm();
init_extends();
var isRef = (ref) => !!ref.current;
var resolveRef = (ref) => isRef(ref) ? ref.current : ref;
var wrapEffect = function(effectImpl, defaultBlendMode) {
  if (defaultBlendMode === void 0) {
    defaultBlendMode = BlendFunction.NORMAL;
  }
  return (0, import_react.forwardRef)(function Wrap(_ref, ref) {
    let _a = _ref, {
      blendFunction,
      opacity
    } = _a, props = __objRest(_a, [
      "blendFunction",
      "opacity"
    ]);
    const invalidate = useThree((state) => state.invalidate);
    const effect = (0, import_react.useMemo)(() => new effectImpl(props), [props]);
    (0, import_react.useLayoutEffect)(() => {
      effect.blendMode.blendFunction = !blendFunction && blendFunction !== 0 ? defaultBlendMode : blendFunction;
      if (opacity !== void 0)
        effect.blendMode.opacity.value = opacity;
      invalidate();
    }, [blendFunction, effect.blendMode, opacity]);
    return import_react.default.createElement("primitive", {
      ref,
      object: effect,
      dispose: null
    });
  });
};
var useVector2 = (props, key) => {
  const vec = props[key];
  return (0, import_react.useMemo)(() => {
    if (vec instanceof Vector2) {
      return new Vector2().set(vec.x, vec.y);
    } else if (Array.isArray(vec)) {
      const [x, y] = vec;
      return new Vector2().set(x, y);
    }
  }, [vec]);
};
var Bloom = wrapEffect(BloomEffect, BlendFunction.SCREEN);
var BrightnessContrast = wrapEffect(BrightnessContrastEffect);
var ChromaticAberration = (0, import_react.forwardRef)(function ChromaticAberration2(props, ref) {
  const offset = useVector2(props, "offset");
  const effect = (0, import_react.useMemo)(() => new ChromaticAberrationEffect(__spreadProps(__spreadValues({}, props), {
    offset
  })), [offset, props]);
  return import_react.default.createElement("primitive", {
    ref,
    object: effect,
    dispose: null
  });
});
var ColorAverage = (0, import_react.forwardRef)(function ColorAverage2(_ref, ref) {
  let {
    blendFunction = BlendFunction.NORMAL
  } = _ref;
  const effect = (0, import_react.useMemo)(() => new ColorAverageEffect(blendFunction), [blendFunction]);
  return import_react.default.createElement("primitive", {
    ref,
    object: effect,
    dispose: null
  });
});
var ColorDepth = wrapEffect(ColorDepthEffect);
var Depth = wrapEffect(DepthEffect);
var EffectComposerContext = (0, import_react.createContext)(null);
var EffectComposer2 = import_react.default.memo((0, import_react.forwardRef)((_ref, ref) => {
  let {
    children,
    camera,
    scene,
    resolutionScale,
    enabled = true,
    renderPriority = 1,
    autoClear = true,
    depthBuffer,
    disableNormalPass,
    stencilBuffer,
    multisampling = 8,
    frameBufferType = HalfFloatType
  } = _ref;
  const {
    gl,
    scene: defaultScene,
    camera: defaultCamera,
    size
  } = useThree();
  scene = scene || defaultScene;
  camera = camera || defaultCamera;
  const [composer, normalPass, downSamplingPass] = (0, import_react.useMemo)(() => {
    const webGL2Available = isWebGL2Available();
    const effectComposer = new EffectComposer(gl, {
      depthBuffer,
      stencilBuffer,
      multisampling: multisampling > 0 && webGL2Available ? multisampling : 0,
      frameBufferType
    });
    effectComposer.addPass(new RenderPass(scene, camera));
    let downSamplingPass2 = null;
    let normalPass2 = null;
    if (!disableNormalPass) {
      normalPass2 = new NormalPass(scene, camera);
      normalPass2.enabled = false;
      effectComposer.addPass(normalPass2);
      if (resolutionScale !== void 0 && webGL2Available) {
        downSamplingPass2 = new DepthDownsamplingPass({
          normalBuffer: normalPass2.texture,
          resolutionScale
        });
        downSamplingPass2.enabled = false;
        effectComposer.addPass(downSamplingPass2);
      }
    }
    return [effectComposer, normalPass2, downSamplingPass2];
  }, [camera, gl, depthBuffer, stencilBuffer, multisampling, frameBufferType, scene, disableNormalPass, resolutionScale]);
  (0, import_react.useEffect)(() => composer == null ? void 0 : composer.setSize(size.width, size.height), [composer, size]);
  useFrame((_, delta) => {
    if (enabled) {
      gl.autoClear = autoClear;
      composer.render(delta);
    }
  }, enabled ? renderPriority : 0);
  const group = (0, import_react.useRef)(null);
  (0, import_react.useLayoutEffect)(() => {
    let effectPass;
    if (group.current && group.current.__r3f && composer) {
      effectPass = new EffectPass(camera, ...group.current.__r3f.objects);
      effectPass.renderToScreen = true;
      composer.addPass(effectPass);
      if (normalPass)
        normalPass.enabled = true;
      if (downSamplingPass)
        downSamplingPass.enabled = true;
    }
    return () => {
      if (effectPass)
        composer == null ? void 0 : composer.removePass(effectPass);
      if (normalPass)
        normalPass.enabled = false;
      if (downSamplingPass)
        downSamplingPass.enabled = false;
    };
  }, [composer, children, camera, normalPass, downSamplingPass]);
  const state = (0, import_react.useMemo)(() => ({
    composer,
    normalPass,
    downSamplingPass,
    resolutionScale,
    camera,
    scene
  }), [composer, normalPass, downSamplingPass, resolutionScale, camera, scene]);
  (0, import_react.useImperativeHandle)(ref, () => composer, [composer]);
  return import_react.default.createElement(EffectComposerContext.Provider, {
    value: state
  }, import_react.default.createElement("group", {
    ref: group
  }, children));
}));
var DepthOfField = (0, import_react.forwardRef)(function DepthOfField2(_ref, ref) {
  let _a = _ref, {
    target,
    depthTexture
  } = _a, props = __objRest(_a, [
    "target",
    "depthTexture"
  ]);
  const invalidate = useThree((state) => state.invalidate);
  const {
    camera
  } = (0, import_react.useContext)(EffectComposerContext);
  const effect = (0, import_react.useMemo)(() => new DepthOfFieldEffect(camera, props), [camera, props]);
  (0, import_react.useLayoutEffect)(() => {
    if (target) {
      const vec = target instanceof Vector3 ? new Vector3().set(target.x, target.y, target.z) : new Vector3().set(target[0], target[1], target[2]);
      effect.target = vec;
    }
    if (depthTexture)
      effect.setDepthTexture(depthTexture.texture, depthTexture.packing);
    invalidate();
  }, [target, depthTexture, effect]);
  return import_react.default.createElement("primitive", {
    ref,
    object: effect,
    dispose: null
  });
});
var DotScreen = wrapEffect(DotScreenEffect);
var Glitch = (0, import_react.forwardRef)(function Glitch2(_ref, ref) {
  let _a = _ref, {
    active = true
  } = _a, props = __objRest(_a, [
    "active"
  ]);
  const invalidate = useThree((state) => state.invalidate);
  const delay = useVector2(props, "delay");
  const duration = useVector2(props, "duration");
  const strength = useVector2(props, "strength");
  const effect = (0, import_react.useMemo)(() => new GlitchEffect(__spreadProps(__spreadValues({}, props), {
    delay,
    duration,
    strength
  })), [delay, duration, props, strength]);
  (0, import_react.useLayoutEffect)(() => {
    effect.mode = active ? props.mode || GlitchMode.SPORADIC : GlitchMode.DISABLED;
    invalidate();
  }, [active, effect, props.mode]);
  return import_react.default.createElement("primitive", {
    ref,
    object: effect,
    dispose: null
  });
});
var GodRays = (0, import_react.forwardRef)(function GodRays2(props, ref) {
  const {
    camera
  } = (0, import_react.useContext)(EffectComposerContext);
  const effect = (0, import_react.useMemo)(() => new GodRaysEffect(camera, props.sun, props), [camera, props]);
  return import_react.default.createElement("primitive", {
    ref,
    object: effect,
    dispose: null
  });
});
var Grid = (0, import_react.forwardRef)(function Grid2(_ref, ref) {
  let _a = _ref, {
    size
  } = _a, props = __objRest(_a, [
    "size"
  ]);
  const invalidate = useThree((state) => state.invalidate);
  const effect = (0, import_react.useMemo)(() => new GridEffect(props), [props]);
  (0, import_react.useLayoutEffect)(() => {
    if (size)
      effect.setSize(size.width, size.height);
    invalidate();
  }, [effect, size]);
  return import_react.default.createElement("primitive", {
    ref,
    object: effect,
    dispose: null
  });
});
var HueSaturation = wrapEffect(HueSaturationEffect);
var Noise = wrapEffect(NoiseEffect, BlendFunction.COLOR_DODGE);
var selectionContext = (0, import_react.createContext)(null);
function Selection(_ref) {
  let {
    children,
    enabled = true
  } = _ref;
  const [selected, select] = (0, import_react.useState)([]);
  const value = (0, import_react.useMemo)(() => ({
    selected,
    select,
    enabled
  }), [selected, select, enabled]);
  return import_react.default.createElement(selectionContext.Provider, {
    value
  }, children);
}
function Select(_ref2) {
  let _a = _ref2, {
    enabled = false,
    children
  } = _a, props = __objRest(_a, [
    "enabled",
    "children"
  ]);
  const group = (0, import_react.useRef)(null);
  const api = (0, import_react.useContext)(selectionContext);
  (0, import_react.useEffect)(() => {
    if (api && enabled) {
      let changed = false;
      const current = [];
      group.current.traverse((o) => {
        o.type === "Mesh" && current.push(o);
        if (api.selected.indexOf(o) === -1)
          changed = true;
      });
      if (changed) {
        api.select((state) => [...state, ...current]);
        return () => {
          api.select((state) => state.filter((selected) => !current.includes(selected)));
        };
      }
    }
  }, [enabled, children]);
  return import_react.default.createElement("group", _extends({
    ref: group
  }, props), children);
}
var Outline = (0, import_react.forwardRef)(function Outline2(_ref, forwardRef2) {
  let _a = _ref, {
    selection = [],
    selectionLayer = 10,
    blendFunction,
    patternTexture,
    edgeStrength,
    pulseSpeed,
    visibleEdgeColor,
    hiddenEdgeColor,
    width,
    height,
    kernelSize,
    blur,
    xRay
  } = _a, props = __objRest(_a, [
    "selection",
    "selectionLayer",
    "blendFunction",
    "patternTexture",
    "edgeStrength",
    "pulseSpeed",
    "visibleEdgeColor",
    "hiddenEdgeColor",
    "width",
    "height",
    "kernelSize",
    "blur",
    "xRay"
  ]);
  const invalidate = useThree((state) => state.invalidate);
  const {
    scene,
    camera
  } = (0, import_react.useContext)(EffectComposerContext);
  const effect = (0, import_react.useMemo)(() => new OutlineEffect(scene, camera, {
    blendFunction,
    patternTexture,
    edgeStrength,
    pulseSpeed,
    visibleEdgeColor,
    hiddenEdgeColor,
    width,
    height,
    kernelSize,
    blur,
    xRay
  }), [blendFunction, blur, camera, edgeStrength, height, hiddenEdgeColor, kernelSize, patternTexture, pulseSpeed, scene, visibleEdgeColor, width, xRay]);
  const api = (0, import_react.useContext)(selectionContext);
  (0, import_react.useEffect)(() => {
    if (!api && selection) {
      effect.selection.set(Array.isArray(selection) ? selection.map(resolveRef) : [resolveRef(selection)]);
      invalidate();
      return () => {
        effect.selection.clear();
        invalidate();
      };
    }
  }, [effect, selection, api]);
  (0, import_react.useEffect)(() => {
    effect.selectionLayer = selectionLayer;
    invalidate();
  }, [effect, selectionLayer]);
  const ref = (0, import_react.useRef)();
  (0, import_react.useEffect)(() => {
    if (api && api.enabled) {
      var _api$selected;
      const effect2 = ref.current;
      if ((_api$selected = api.selected) != null && _api$selected.length) {
        effect2.selection.set(api.selected);
        invalidate();
        return () => {
          effect2.selection.clear();
          invalidate();
        };
      }
    }
  }, [api]);
  return import_react.default.createElement("primitive", {
    ref: react_merge_refs_esm_default([ref, forwardRef2]),
    object: effect
  });
});
var Pixelation = (0, import_react.forwardRef)(function Pixelation2(_ref, ref) {
  let {
    granularity = 5
  } = _ref;
  const effect = (0, import_react.useMemo)(() => new PixelationEffect(granularity), [granularity]);
  return import_react.default.createElement("primitive", {
    ref,
    object: effect,
    dispose: null
  });
});
var Scanline = wrapEffect(ScanlineEffect, BlendFunction.OVERLAY);
var addLight = (light, effect) => light.layers.enable(effect.selection.layer);
var removeLight = (light, effect) => light.layers.disable(effect.selection.layer);
var SelectiveBloom = (0, import_react.forwardRef)(function SelectiveBloom2(_ref, forwardRef2) {
  let {
    selection = [],
    selectionLayer = 10,
    lights = [],
    luminanceThreshold,
    luminanceSmoothing,
    intensity,
    width,
    height,
    kernelSize
  } = _ref;
  if (lights.length === 0) {
    console.warn("SelectiveBloom requires lights to work.");
  }
  const invalidate = useThree((state) => state.invalidate);
  const {
    scene,
    camera
  } = (0, import_react.useContext)(EffectComposerContext);
  const effect = (0, import_react.useMemo)(() => new SelectiveBloomEffect(scene, camera, {
    blendFunction: BlendFunction.SCREEN,
    luminanceThreshold,
    luminanceSmoothing,
    intensity,
    width,
    height,
    kernelSize
  }), [camera, height, intensity, kernelSize, luminanceSmoothing, luminanceThreshold, scene, width]);
  const api = (0, import_react.useContext)(selectionContext);
  (0, import_react.useEffect)(() => {
    if (!api && selection) {
      effect.selection.set(Array.isArray(selection) ? selection.map(resolveRef) : [resolveRef(selection)]);
      invalidate();
      return () => {
        effect.selection.clear();
        invalidate();
      };
    }
  }, [effect, selection, api]);
  (0, import_react.useEffect)(() => {
    effect.selection.layer = selectionLayer;
    invalidate();
  }, [effect, selectionLayer]);
  (0, import_react.useEffect)(() => {
    if (lights && lights.length > 0) {
      lights.forEach((light) => addLight(resolveRef(light), effect));
      invalidate();
      return () => {
        lights.forEach((light) => removeLight(resolveRef(light), effect));
        invalidate();
      };
    }
  }, [effect, lights, selectionLayer]);
  const ref = (0, import_react.useRef)();
  (0, import_react.useEffect)(() => {
    if (api && api.enabled) {
      var _api$selected;
      const effect2 = ref.current;
      if ((_api$selected = api.selected) != null && _api$selected.length) {
        effect2.selection.set(api.selected);
        invalidate();
        return () => {
          effect2.selection.clear();
          invalidate();
        };
      }
    }
  }, [api]);
  return import_react.default.createElement("primitive", {
    ref: react_merge_refs_esm_default([ref, forwardRef2]),
    object: effect,
    dispose: null
  });
});
var Sepia = wrapEffect(SepiaEffect);
var SSAO = (0, import_react.forwardRef)(function SSAO2(props, ref) {
  const {
    camera,
    normalPass,
    downSamplingPass,
    resolutionScale
  } = (0, import_react.useContext)(EffectComposerContext);
  const effect = (0, import_react.useMemo)(() => {
    if (normalPass === null && downSamplingPass === null) {
      console.error("Please enable the NormalPass in the EffectComposer in order to use SSAO.");
      return null;
    }
    return new SSAOEffect(camera, normalPass && !downSamplingPass ? normalPass.texture : null, __spreadValues({
      blendFunction: BlendFunction.MULTIPLY,
      samples: 30,
      rings: 4,
      distanceThreshold: 1,
      distanceFalloff: 0,
      rangeThreshold: 0.5,
      rangeFalloff: 0.1,
      luminanceInfluence: 0.9,
      radius: 20,
      scale: 0.5,
      bias: 0.5,
      intensity: 1,
      color: null,
      normalDepthBuffer: downSamplingPass ? downSamplingPass.texture : null,
      resolutionScale: resolutionScale != null ? resolutionScale : 1,
      depthAwareUpsampling: true
    }, props));
  }, [camera, normalPass, props]);
  return import_react.default.createElement("primitive", {
    ref,
    object: effect,
    dispose: null
  });
});
var SMAA = (0, import_react.forwardRef)(function SMAA2(_ref, ref) {
  let {
    preset = SMAAPreset.HIGH,
    edgeDetectionMode = EdgeDetectionMode.COLOR
  } = _ref;
  const smaaProps = useLoader(SMAAImageLoader, "");
  const effect = (0, import_react.useMemo)(() => new SMAAEffect(...smaaProps, preset, edgeDetectionMode), [smaaProps, preset, edgeDetectionMode]);
  return import_react.default.createElement("primitive", {
    ref,
    object: effect,
    dispose: null
  });
});
var Texture = (0, import_react.forwardRef)(function Texture2(_ref, ref) {
  let _a = _ref, {
    textureSrc,
    texture
  } = _a, props = __objRest(_a, [
    "textureSrc",
    "texture"
  ]);
  const t = useLoader(TextureLoader, textureSrc);
  (0, import_react.useLayoutEffect)(() => {
    t.encoding = sRGBEncoding;
    t.wrapS = t.wrapT = RepeatWrapping;
  }, [t]);
  const effect = (0, import_react.useMemo)(() => new TextureEffect(__spreadProps(__spreadValues({}, props), {
    texture: t || texture
  })), [props, t, texture]);
  return import_react.default.createElement("primitive", {
    ref,
    object: effect,
    dispose: null
  });
});
var ToneMapping = wrapEffect(ToneMappingEffect);
var Vignette = wrapEffect(VignetteEffect);
var ShockWave = wrapEffect(ShockWaveEffect);
var LUT = (0, import_react.forwardRef)(function LUT2(_ref, ref) {
  let _a = _ref, {
    lut,
    tetrahedralInterpolation
  } = _a, props = __objRest(_a, [
    "lut",
    "tetrahedralInterpolation"
  ]);
  const invalidate = useThree((state) => state.invalidate);
  const effect = (0, import_react.useMemo)(() => new LUT3DEffect(lut, props), [lut, props]);
  (0, import_react.useLayoutEffect)(() => {
    if (lut)
      effect.setLUT(lut);
    if (tetrahedralInterpolation)
      effect.setTetrahedralInterpolationEnabled(tetrahedralInterpolation);
    invalidate();
  }, [effect, lut, tetrahedralInterpolation]);
  return import_react.default.createElement("primitive", {
    ref,
    object: effect,
    dispose: null
  });
});
export {
  Bloom,
  BrightnessContrast,
  ChromaticAberration,
  ColorAverage,
  ColorDepth,
  Depth,
  DepthOfField,
  DotScreen,
  EffectComposer2 as EffectComposer,
  EffectComposerContext,
  Glitch,
  GodRays,
  Grid,
  HueSaturation,
  LUT,
  Noise,
  Outline,
  Pixelation,
  SMAA,
  SSAO,
  Scanline,
  Select,
  Selection,
  SelectiveBloom,
  Sepia,
  ShockWave,
  Texture,
  ToneMapping,
  Vignette,
  selectionContext
};
//# sourceMappingURL=@react-three_postprocessing.js.map
